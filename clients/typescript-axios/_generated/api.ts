/* tslint:disable */
/* eslint-disable */
/**
 * Basta API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ModelsAccount
 */
export interface ModelsAccount {
    /**
     * Should sales be shown in basta bid client (Basta pages).
     * @type {boolean}
     * @memberof ModelsAccount
     */
    'basta_bid_client'?: boolean;
    /**
     * Creation date and time for the account
     * @type {TimestamppbTimestamp}
     * @memberof ModelsAccount
     */
    'created'?: TimestamppbTimestamp;
    /**
     * Email associated with account
     * @type {string}
     * @memberof ModelsAccount
     */
    'email'?: string;
    /**
     * Identifier for the account and used as a public identifier for pages
     * @type {string}
     * @memberof ModelsAccount
     */
    'handle'?: string;
    /**
     * Unique ID for the account
     * @type {string}
     * @memberof ModelsAccount
     */
    'id'?: string;
    /**
     * Modified date and time for the account. Default nil
     * @type {TimestamppbTimestamp}
     * @memberof ModelsAccount
     */
    'modified'?: TimestamppbTimestamp;
    /**
     * Display name for account
     * @type {string}
     * @memberof ModelsAccount
     */
    'name'?: string;
    /**
     * Populated if account has accepted seller terms.
     * @type {ModelsSellerTerms}
     * @memberof ModelsAccount
     */
    'terms'?: ModelsSellerTerms;
}
/**
 * 
 * @export
 * @interface ModelsAccountResponse
 */
export interface ModelsAccountResponse {
    /**
     * 
     * @type {ModelsAccount}
     * @memberof ModelsAccountResponse
     */
    'account'?: ModelsAccount;
}
/**
 * 
 * @export
 * @interface ModelsBidIncrementTable
 */
export interface ModelsBidIncrementTable {
    /**
     * 
     * @type {Array<ModelsRangeRule>}
     * @memberof ModelsBidIncrementTable
     */
    'rules'?: Array<ModelsRangeRule>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ModelsClosingMethod = {
    ClosingMethod_NOT_SET: 0,
    ClosingMethod_ONE_BY_ONE: 1,
    ClosingMethod_OVERLAPPING: 2,
    ClosingMethod_NONE: 3
} as const;

export type ModelsClosingMethod = typeof ModelsClosingMethod[keyof typeof ModelsClosingMethod];


/**
 * 
 * @export
 * @interface ModelsCreateSaleResponse
 */
export interface ModelsCreateSaleResponse {
    /**
     * 
     * @type {ModelsSale}
     * @memberof ModelsCreateSaleResponse
     */
    'sale'?: ModelsSale;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ModelsCurrency = {
    Currency_CURRENCY_NOT_SET: 0,
    Currency_USD: 1,
    Currency_ISK: 2
} as const;

export type ModelsCurrency = typeof ModelsCurrency[keyof typeof ModelsCurrency];


/**
 * 
 * @export
 * @interface ModelsGetSaleResponse
 */
export interface ModelsGetSaleResponse {
    /**
     * 
     * @type {ModelsSale}
     * @memberof ModelsGetSaleResponse
     */
    'sale'?: ModelsSale;
}
/**
 * 
 * @export
 * @interface ModelsPaddle
 */
export interface ModelsPaddle {
    /**
     * 
     * @type {TimestamppbTimestamp}
     * @memberof ModelsPaddle
     */
    'created'?: TimestamppbTimestamp;
    /**
     * 
     * @type {string}
     * @memberof ModelsPaddle
     */
    'identifier'?: string;
    /**
     * 
     * @type {ModelsPaddleType}
     * @memberof ModelsPaddle
     */
    'type'?: ModelsPaddleType;
    /**
     * 
     * @type {string}
     * @memberof ModelsPaddle
     */
    'user_id'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ModelsPaddleType = {
    PaddleType_PADDLE_TYPE_NOT_SET: 0,
    PaddleType_PHONE: 1,
    PaddleType_IN_ROOM: 2
} as const;

export type ModelsPaddleType = typeof ModelsPaddleType[keyof typeof ModelsPaddleType];


/**
 * 
 * @export
 * @interface ModelsRangeRule
 */
export interface ModelsRangeRule {
    /**
     * 
     * @type {number}
     * @memberof ModelsRangeRule
     */
    'high_range'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsRangeRule
     */
    'low_range'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsRangeRule
     */
    'step'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ModelsReserveAutoBidMethod = {
    ReserveAutoBidMethod_STANDARD_NO_AUTOBID: 0,
    ReserveAutoBidMethod_MAX_BID_BELOW_RESERVE_IS_MET: 1
} as const;

export type ModelsReserveAutoBidMethod = typeof ModelsReserveAutoBidMethod[keyof typeof ModelsReserveAutoBidMethod];


/**
 * 
 * @export
 * @interface ModelsSale
 */
export interface ModelsSale {
    /**
     * 
     * @type {string}
     * @memberof ModelsSale
     */
    'account_id'?: string;
    /**
     * Should the auction be shown on the Basta bid client (Basta pages).
     * @type {boolean}
     * @memberof ModelsSale
     */
    'basta_bid_client'?: boolean;
    /**
     * 
     * @type {ModelsBidIncrementTable}
     * @memberof ModelsSale
     */
    'bid_increment_table'?: ModelsBidIncrementTable;
    /**
     * 
     * @type {ModelsClosingMethod}
     * @memberof ModelsSale
     */
    'closing_method'?: ModelsClosingMethod;
    /**
     * Closing time countdown (Sniping period) in millisecods
     * @type {number}
     * @memberof ModelsSale
     */
    'closing_time_countdown'?: number;
    /**
     * Created timestamp
     * @type {TimestamppbTimestamp}
     * @memberof ModelsSale
     */
    'created_timestamp'?: TimestamppbTimestamp;
    /**
     * 
     * @type {ModelsCurrency}
     * @memberof ModelsSale
     */
    'currency'?: ModelsCurrency;
    /**
     * 
     * @type {boolean}
     * @memberof ModelsSale
     */
    'hidden'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ModelsSale
     */
    'id'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ModelsSale
     */
    'item_ids'?: Array<string>;
    /**
     * 
     * @type {Array<ModelsPaddle>}
     * @memberof ModelsSale
     */
    'paddles'?: Array<ModelsPaddle>;
    /**
     * 
     * @type {ModelsReserveAutoBidMethod}
     * @memberof ModelsSale
     */
    'reserve_auto_bid_method'?: ModelsReserveAutoBidMethod;
    /**
     * 
     * @type {ModelsSaleDates}
     * @memberof ModelsSale
     */
    'sale_dates'?: ModelsSaleDates;
    /**
     * 
     * @type {ModelsSaleType}
     * @memberof ModelsSale
     */
    'sale_type'?: ModelsSaleType;
    /**
     * 
     * @type {ModelsSaleStatus}
     * @memberof ModelsSale
     */
    'status'?: ModelsSaleStatus;
}


/**
 * 
 * @export
 * @interface ModelsSaleDates
 */
export interface ModelsSaleDates {
    /**
     * 
     * @type {TimestamppbTimestamp}
     * @memberof ModelsSaleDates
     */
    'closing_date'?: TimestamppbTimestamp;
    /**
     * 
     * @type {TimestamppbTimestamp}
     * @memberof ModelsSaleDates
     */
    'live_date'?: TimestamppbTimestamp;
    /**
     * 
     * @type {TimestamppbTimestamp}
     * @memberof ModelsSaleDates
     */
    'open_date'?: TimestamppbTimestamp;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ModelsSaleStatus = {
    SaleStatus_SALE_STATUS_NOT_SET: 0,
    SaleStatus_UNPUBLISHED: 1,
    SaleStatus_PUBLISHED: 2,
    SaleStatus_OPEN: 3,
    SaleStatus_CLOSING: 4,
    SaleStatus_CLOSED: 5,
    SaleStatus_PAUSED: 6,
    SaleStatus_PROCESSING: 7,
    SaleStatus_SALE_LIVE: 8
} as const;

export type ModelsSaleStatus = typeof ModelsSaleStatus[keyof typeof ModelsSaleStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const ModelsSaleType = {
    SaleType_ONLINE_TIMED: 0,
    SaleType_LIVE: 1
} as const;

export type ModelsSaleType = typeof ModelsSaleType[keyof typeof ModelsSaleType];


/**
 * 
 * @export
 * @interface ModelsSellerTerms
 */
export interface ModelsSellerTerms {
    /**
     * Identifier of the user who has accepted the seller terms.
     * @type {string}
     * @memberof ModelsSellerTerms
     */
    'accepted_by'?: string;
    /**
     * Unix timestamp of when seller terms were accepted for the account. DateTime String RFC3999
     * @type {TimestamppbTimestamp}
     * @memberof ModelsSellerTerms
     */
    'accepted_date'?: TimestamppbTimestamp;
}
/**
 * 
 * @export
 * @interface ModelsUpdateSaleResponse
 */
export interface ModelsUpdateSaleResponse {
    /**
     * 
     * @type {ModelsSale}
     * @memberof ModelsUpdateSaleResponse
     */
    'sale'?: ModelsSale;
}
/**
 * 
 * @export
 * @interface TimestamppbTimestamp
 */
export interface TimestamppbTimestamp {
    /**
     * Non-negative fractions of a second at nanosecond resolution. Negative second values with fractions must still have non-negative nanos values that count forward in time. Must be from 0 to 999,999,999 inclusive.
     * @type {number}
     * @memberof TimestamppbTimestamp
     */
    'nanos'?: number;
    /**
     * Represents seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.
     * @type {number}
     * @memberof TimestamppbTimestamp
     */
    'seconds'?: number;
}

/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get account by id
         * @summary Get account by id
         * @param {string} accountId Your provided Basta account id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountIdGet: async (accountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsAccountIdGet', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create account
         * @summary Create account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get account by id
         * @summary Get account by id
         * @param {string} accountId Your provided Basta account id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAccountIdGet(accountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAccountIdGet(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.accountsAccountIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create account
         * @summary Create account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelsAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.accountsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * Get account by id
         * @summary Get account by id
         * @param {string} accountId Your provided Basta account id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountIdGet(accountId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.accountsAccountIdGet(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create account
         * @summary Create account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPost(options?: RawAxiosRequestConfig): AxiosPromise<ModelsAccountResponse> {
            return localVarFp.accountsPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * Get account by id
     * @summary Get account by id
     * @param {string} accountId Your provided Basta account id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsAccountIdGet(accountId: string, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsAccountIdGet(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create account
     * @summary Create account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsPost(options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsPost(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SalesApi - axios parameter creator
 * @export
 */
export const SalesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all sales
         * @summary Get all sales
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sales`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create sale
         * @summary Create sale
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sales`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get sale by ID
         * @summary Get sale
         * @param {string} saleId Your provided Basta sale id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesSaleIdGet: async (saleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'saleId' is not null or undefined
            assertParamExists('salesSaleIdGet', 'saleId', saleId)
            const localVarPath = `/sales/{saleId}`
                .replace(`{${"saleId"}}`, encodeURIComponent(String(saleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update sale
         * @summary Update sale
         * @param {string} saleId Your provided Basta sale id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesSaleIdPut: async (saleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'saleId' is not null or undefined
            assertParamExists('salesSaleIdPut', 'saleId', saleId)
            const localVarPath = `/sales/{saleId}`
                .replace(`{${"saleId"}}`, encodeURIComponent(String(saleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SalesApi - functional programming interface
 * @export
 */
export const SalesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SalesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all sales
         * @summary Get all sales
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async salesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsGetSaleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.salesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SalesApi.salesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create sale
         * @summary Create sale
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async salesPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelsCreateSaleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.salesPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SalesApi.salesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get sale by ID
         * @summary Get sale
         * @param {string} saleId Your provided Basta sale id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async salesSaleIdGet(saleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelsGetSaleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.salesSaleIdGet(saleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SalesApi.salesSaleIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update sale
         * @summary Update sale
         * @param {string} saleId Your provided Basta sale id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async salesSaleIdPut(saleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelsUpdateSaleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.salesSaleIdPut(saleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SalesApi.salesSaleIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SalesApi - factory interface
 * @export
 */
export const SalesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SalesApiFp(configuration)
    return {
        /**
         * Get all sales
         * @summary Get all sales
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<ModelsGetSaleResponse>> {
            return localVarFp.salesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Create sale
         * @summary Create sale
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesPost(options?: RawAxiosRequestConfig): AxiosPromise<ModelsCreateSaleResponse> {
            return localVarFp.salesPost(options).then((request) => request(axios, basePath));
        },
        /**
         * Get sale by ID
         * @summary Get sale
         * @param {string} saleId Your provided Basta sale id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesSaleIdGet(saleId: string, options?: RawAxiosRequestConfig): AxiosPromise<ModelsGetSaleResponse> {
            return localVarFp.salesSaleIdGet(saleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update sale
         * @summary Update sale
         * @param {string} saleId Your provided Basta sale id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesSaleIdPut(saleId: string, options?: RawAxiosRequestConfig): AxiosPromise<ModelsUpdateSaleResponse> {
            return localVarFp.salesSaleIdPut(saleId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SalesApi - object-oriented interface
 * @export
 * @class SalesApi
 * @extends {BaseAPI}
 */
export class SalesApi extends BaseAPI {
    /**
     * Get all sales
     * @summary Get all sales
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesApi
     */
    public salesGet(options?: RawAxiosRequestConfig) {
        return SalesApiFp(this.configuration).salesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create sale
     * @summary Create sale
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesApi
     */
    public salesPost(options?: RawAxiosRequestConfig) {
        return SalesApiFp(this.configuration).salesPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get sale by ID
     * @summary Get sale
     * @param {string} saleId Your provided Basta sale id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesApi
     */
    public salesSaleIdGet(saleId: string, options?: RawAxiosRequestConfig) {
        return SalesApiFp(this.configuration).salesSaleIdGet(saleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update sale
     * @summary Update sale
     * @param {string} saleId Your provided Basta sale id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesApi
     */
    public salesSaleIdPut(saleId: string, options?: RawAxiosRequestConfig) {
        return SalesApiFp(this.configuration).salesSaleIdPut(saleId, options).then((request) => request(this.axios, this.basePath));
    }
}



